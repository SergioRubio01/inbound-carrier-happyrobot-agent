name: Deploy HappyRobot FDE Infrastructure

on:
  push:
    branches:
      - master
      - main
    paths:
      - 'infrastructure/pulumi/**'
      - 'src/**'
      - 'Dockerfile.api'
      - '.github/workflows/deploy.yml'
    tags:
      - 'v*.*.*'  # Trigger on semantic version tags
      - 'v*.*.*-*'  # Include pre-release tags

  pull_request:
    branches:
      - master
      - main
    paths:
      - 'infrastructure/pulumi/**'
      - 'src/**'
      - 'Dockerfile.api'

  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - production

env:
  AWS_REGION: eu-south-2  # Spain region for compliance
  # ECR repository name must match the name created by Pulumi infrastructure
  # Naming convention: happyrobot-{environment}-containers-api
  # This matches the ECR repository created in infrastructure/pulumi/components/containers.ts
  ECR_API_REPOSITORY: happyrobot-dev-containers-api
  PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}

jobs:
  # Test and lint before deployment
  test:
    name: Run Tests and Quality Checks
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Cache Poetry dependencies
        uses: actions/cache@v3
        with:
          path: .venv
          key: venv-${{ runner.os }}-python-3.12-${{ hashFiles('**/pyproject.toml') }}

      - name: Install Python dependencies with Poetry
        run: |
          poetry install --with dev --no-interaction --no-ansi

      - name: Run Python linting
        run: |
          poetry run ruff check .
          poetry run ruff format --check .

      - name: Run Python type checking
        run: |
          poetry run mypy .

      - name: Run Python tests
        run: |
          poetry run pytest -m "not integration" --cov=src --cov-report=term-missing

  # Deploy infrastructure first to create ECR repositories
  deploy-infrastructure:
    name: Deploy Infrastructure
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    strategy:
      matrix:
        environment:
          - ${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'dev' }}

    environment:
      name: ${{ matrix.environment }}
      url: ${{ steps.get-outputs.outputs.loadbalancer-dns-name }}

    outputs:
      ecr-registry: ${{ steps.login-ecr.outputs.registry }}
      api-repository: ${{ env.ECR_API_REPOSITORY }}
      loadbalancer-dns-name: ${{ steps.get-outputs.outputs.loadbalancer-dns-name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Cache npm dependencies
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('infrastructure/pulumi/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install Pulumi dependencies
        run: |
          cd infrastructure/pulumi
          npm ci

      - name: Install Pulumi CLI
        uses: pulumi/actions@v4

      - name: Create or select Pulumi stack
        run: |
          cd infrastructure/pulumi
          pulumi login
          # Try to select the stack, if it doesn't exist, create it
          pulumi stack select happyrobot-fde 2>/dev/null || pulumi stack init happyrobot-fde
          # Set the AWS region config
          pulumi config set aws:region ${{ env.AWS_REGION }}
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}

      - name: Deploy with Pulumi
        id: pulumi
        uses: pulumi/actions@v4
        with:
          command: up
          stack-name: happyrobot-fde
          work-dir: infrastructure/pulumi
          cloud-url: https://api.pulumi.com
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE }}

      - name: Get Pulumi outputs
        id: get-outputs
        run: |
          cd infrastructure/pulumi
          echo "loadbalancer-dns-name=$(pulumi stack output loadBalancerDnsName -s happyrobot-fde 2>/dev/null || echo '')" >> $GITHUB_OUTPUT
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}

  # Build and push Docker images after infrastructure is ready
  build:
    name: Build and Push Docker Images
    needs: [test, deploy-infrastructure]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    outputs:
      api-image-tag: ${{ steps.meta.outputs.api-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}


      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image tags
        id: meta
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          SHORT_SHA=${GITHUB_SHA::8}

          # If this is a tag, use the tag as part of the image tag
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
            API_TAG="${{ needs.deploy-infrastructure.outputs.ecr-registry }}/${{ needs.deploy-infrastructure.outputs.api-repository }}:${VERSION}"
            API_LATEST="${{ needs.deploy-infrastructure.outputs.ecr-registry }}/${{ needs.deploy-infrastructure.outputs.api-repository }}:latest"

            # For production releases (non-prerelease), also tag as stable
            if [[ ! "$VERSION" =~ - ]]; then
              API_STABLE="${{ needs.deploy-infrastructure.outputs.ecr-registry }}/${{ needs.deploy-infrastructure.outputs.api-repository }}:stable"
              echo "api-stable=${API_STABLE}" >> $GITHUB_OUTPUT
            fi
          else
            API_TAG="${{ needs.deploy-infrastructure.outputs.ecr-registry }}/${{ needs.deploy-infrastructure.outputs.api-repository }}:${TIMESTAMP}-${SHORT_SHA}"
            API_LATEST="${{ needs.deploy-infrastructure.outputs.ecr-registry }}/${{ needs.deploy-infrastructure.outputs.api-repository }}:latest"
          fi

          echo "api-tag=${API_TAG}" >> $GITHUB_OUTPUT
          echo "api-latest=${API_LATEST}" >> $GITHUB_OUTPUT

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.api
          push: true
          tags: |
            ${{ steps.meta.outputs.api-tag }}
            ${{ steps.meta.outputs.api-latest }}
            ${{ steps.meta.outputs.api-stable }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  # Update ECS services with new images
  deploy:
    name: Update ECS Services
    needs: [test, deploy-infrastructure, build]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    strategy:
      matrix:
        environment:
          - ${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'dev' }}

    environment:
      name: ${{ matrix.environment }}
      url: ${{ needs.deploy-infrastructure.outputs.loadbalancer-dns-name }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS services with new images
        if: needs.build.outputs.api-image-tag != ''
        run: |
          # Update API service
          aws ecs update-service \
            --cluster happyrobot-dev-containers-cluster \
            --service happyrobot-dev-containers-api-service \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

          # Note: Frontend service not deployed yet
          # # Update Web service
          # aws ecs update-service \
          #   --cluster happyrobot-dev-containers-cluster \
          #   --service happyrobot-frontend \
          #   --force-new-deployment \
          #   --region ${{ env.AWS_REGION }}

      - name: Wait for services to stabilize
        run: |
          echo "Waiting for API service to stabilize..."
          aws ecs wait services-stable \
            --cluster happyrobot-dev-containers-cluster \
            --services happyrobot-dev-containers-api-service \
            --region ${{ env.AWS_REGION }}

          # Note: Frontend service not deployed yet
          # echo "Waiting for Web service to stabilize..."
          # aws ecs wait services-stable \
          #   --cluster happyrobot-dev-containers-cluster \
          #   --services happyrobot-frontend \
          #   --region ${{ env.AWS_REGION }}

      - name: Run health checks
        run: |
          ALB_DNS="${{ needs.deploy-infrastructure.outputs.loadbalancer-dns-name }}"

          echo "Running health checks against http://${ALB_DNS}"

          # Check API health
          curl -f "http://${ALB_DNS}/api/v1/health" || exit 1
          echo "‚úÖ API health check passed"

          # Note: Frontend not deployed yet
          # # Check Web health (basic connectivity)
          # curl -f "http://${ALB_DNS}/" -I || exit 1
          # echo "‚úÖ Web health check passed"

  # Notify on deployment completion
  notify:
    name: Notify Deployment Status
    needs: [deploy-infrastructure, deploy]
    runs-on: ubuntu-latest
    if: always() && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')

    steps:
      - name: Notify Success
        if: needs.deploy.result == 'success'
        run: |
          echo "üöÄ Deployment completed successfully!"
          echo "Environment: ${{ matrix.environment || 'dev' }}"
          echo "Commit: ${{ github.sha }}"
          echo "Load Balancer: ${{ needs.deploy-infrastructure.outputs.loadbalancer-dns-name }}"

      - name: Notify Failure
        if: needs.deploy.result == 'failure'
        run: |
          echo "‚ùå Deployment failed!"
          echo "Check the logs for more details."
          exit 1
